// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OkmsSecretResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"cas": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Description:         "Check-and-set guard. Only used on update operations: must equal the current secret version for the update to succeed. Ignored on create.",
			MarkdownDescription: "Check-and-set guard. Only used on update operations: must equal the current secret version for the update to succeed. Ignored on create.",
		},
		"iam": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Resource display name",
					MarkdownDescription: "Resource display name",
				},
				"id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique identifier of the resource",
					MarkdownDescription: "Unique identifier of the resource",
				},
				"tags": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Resource tags. Tags that were internally computed are prefixed with ovh:",
					MarkdownDescription: "Resource tags. Tags that were internally computed are prefixed with ovh:",
				},
				"urn": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique resource name used in policies",
					MarkdownDescription: "Unique resource name used in policies",
				},
			},
			CustomType: IamType{
				ObjectType: types.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "IAM resource metadata embedded in services models",
			MarkdownDescription: "IAM resource metadata embedded in services models",
		},
		"include_data": schema.BoolAttribute{
			CustomType:         ovhtypes.TfBoolType{},
			Optional:           true,
			Computed:           true,
			DeprecationMessage: "No effect; will be removed in a future version.",
		},
		"metadata": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"cas_required": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Optional:            true,
					Computed:            true,
					Description:         "The “Cas” parameter will be required for each write request if set to true. When the “cas” (Check and set) is specified, the current version of the secret is verified before updating it.",
					MarkdownDescription: "The “Cas” parameter will be required for each write request if set to true. When the “cas” (Check and set) is specified, the current version of the secret is verified before updating it.",
				},
				"created_at": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Time of creation of the secret",
					MarkdownDescription: "Time of creation of the secret",
				},
				"current_version": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "The secret version",
					MarkdownDescription: "The secret version",
				},
				"custom_metadata": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Optional:            true,
					Computed:            true,
					Description:         "Custom metadata",
					MarkdownDescription: "Custom metadata",
				},
				"deactivate_version_after": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Time duration before a version is deactivated",
					MarkdownDescription: "Time duration before a version is deactivated",
				},
				"max_versions": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "The number of versions to keep (10 default)",
					MarkdownDescription: "The number of versions to keep (10 default)",
				},
				"oldest_version": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "The secret oldest version",
					MarkdownDescription: "The secret oldest version",
				},
				"updated_at": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Time of the last update of the secret",
					MarkdownDescription: "Time of the last update of the secret",
				},
			},
			CustomType: MetadataType{
				ObjectType: types.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "Create a secret metadata",
			MarkdownDescription: "Create a secret metadata",
		},
		"okms_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Okms ID",
			MarkdownDescription: "Okms ID",
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"path": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Secret path",
			MarkdownDescription: "Secret path",
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"version": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"created_at": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Time of creation of the secret version",
					MarkdownDescription: "Time of creation of the secret version",
				},
				"data": schema.StringAttribute{
					CustomType: ovhtypes.TfStringType{},
					Required:   true,
					Sensitive:  true,
				},
				"deactivated_at": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Time of deactivation of the secret version",
					MarkdownDescription: "Time of deactivation of the secret version",
				},
				"id": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "Secret version",
					MarkdownDescription: "Secret version",
				},
				"state": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "State of the secret version",
					MarkdownDescription: "State of the secret version",
				},
			},
			Required:            true,
			Description:         "Create an OKMS secret version",
			MarkdownDescription: "Create an OKMS secret version",
		},
	}

	return schema.Schema{
		Description: "",
		Attributes:  attrs,
	}
}

func (v MetadataValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.CasRequired.IsNull() && !v.CasRequired.IsUnknown() {
		toMarshal["casRequired"] = v.CasRequired
	}
	if !v.CustomMetadata.IsNull() && !v.CustomMetadata.IsUnknown() {
		toMarshal["customMetadata"] = v.CustomMetadata
	}
	if !v.DeactivateVersionAfter.IsNull() && !v.DeactivateVersionAfter.IsUnknown() {
		toMarshal["deactivateVersionAfter"] = v.DeactivateVersionAfter
	}
	if !v.MaxVersions.IsNull() && !v.MaxVersions.IsUnknown() {
		toMarshal["maxVersions"] = v.MaxVersions
	}

	return json.Marshal(toMarshal)
}

type SecretVersionValue struct {
	CreatedAt     ovhtypes.TfStringValue `tfsdk:"created_at" json:"createdAt"`
	Data          ovhtypes.TfStringValue `tfsdk:"data" json:"data"`
	DeactivatedAt ovhtypes.TfStringValue `tfsdk:"deactivated_at" json:"deactivatedAt"`
	Id            ovhtypes.TfInt64Value  `tfsdk:"id" json:"id"`
	State         ovhtypes.TfStringValue `tfsdk:"state" json:"state"`
	state         attr.ValueState
}

func (v SecretVersionValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.CreatedAt.IsNull() && !v.CreatedAt.IsUnknown() {
		toMarshal["createdAt"] = v.CreatedAt
	}
	if !v.Data.IsNull() && !v.Data.IsUnknown() {
		toMarshal["data"] = v.Data
	}
	if !v.DeactivatedAt.IsNull() && !v.DeactivatedAt.IsUnknown() {
		toMarshal["deactivatedAt"] = v.DeactivatedAt
	}
	if !v.Id.IsNull() && !v.Id.IsUnknown() {
		toMarshal["id"] = v.Id
	}
	if !v.State.IsNull() && !v.State.IsUnknown() {
		toMarshal["state"] = v.State
	}

	return json.Marshal(toMarshal)
}

// Custom unmarshal to accept either a JSON string or any JSON value (object/array/number/bool)
// for the secret version's data field. We always store it as its raw JSON string representation
// in the TfStringValue so Terraform diffing works against the jsonencode(...) input provided
// by the user.
func (v *SecretVersionValue) UnmarshalJSON(b []byte) error {
	// Define an alias without method to avoid recursion
	type rawAlias struct {
		CreatedAt     *string         `json:"createdAt"`
		Data          json.RawMessage `json:"data"`
		DeactivatedAt *string         `json:"deactivatedAt"`
		Id            *int64          `json:"id"`
		State         *string         `json:"state"`
	}
	var tmp rawAlias
	if err := json.Unmarshal(b, &tmp); err != nil {
		return err
	}

	// CreatedAt
	if tmp.CreatedAt != nil {
		v.CreatedAt = ovhtypes.NewTfStringValue(*tmp.CreatedAt)
	} else {
		v.CreatedAt = ovhtypes.NewTfStringNull()
	}
	// Data: accept any JSON. If null -> null, else raw bytes as string
	if len(tmp.Data) == 0 || string(tmp.Data) == "null" {
		v.Data = ovhtypes.NewTfStringNull()
	} else {
		// Store exact raw JSON (no reformat) as string
		v.Data = ovhtypes.NewTfStringValue(string(tmp.Data))
	}
	// DeactivatedAt
	if tmp.DeactivatedAt != nil {
		v.DeactivatedAt = ovhtypes.NewTfStringValue(*tmp.DeactivatedAt)
	} else {
		v.DeactivatedAt = ovhtypes.NewTfStringNull()
	}
	// Id
	if tmp.Id != nil {
		v.Id = ovhtypes.NewTfInt64Value(*tmp.Id)
	} else {
		v.Id = ovhtypes.NewTfInt64ValueNull()
	}
	// State
	if tmp.State != nil {
		v.State = ovhtypes.NewTfStringValue(*tmp.State)
	} else {
		v.State = ovhtypes.NewTfStringNull()
	}

	v.state = attr.ValueStateKnown
	return nil
}
