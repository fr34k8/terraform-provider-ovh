// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OkmsSecretDataSourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"data": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Sensitive:           true,
			Description:         "Secret data as a JSON string when include_data is true (sensitive)",
			MarkdownDescription: "Secret data as a JSON string when include_data is true (sensitive)",
		},
		"iam": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Resource display name",
					MarkdownDescription: "Resource display name",
				},
				"id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique identifier of the resource",
					MarkdownDescription: "Unique identifier of the resource",
				},
				"tags": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Resource tags. Tags that were internally computed are prefixed with ovh:",
					MarkdownDescription: "Resource tags. Tags that were internally computed are prefixed with ovh:",
				},
				"urn": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique resource name used in policies",
					MarkdownDescription: "Unique resource name used in policies",
				},
			},
			CustomType: IamType{
				ObjectType: types.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "IAM resource metadata embedded in services models",
			MarkdownDescription: "IAM resource metadata embedded in services models",
		},
		"include_data": schema.BoolAttribute{
			CustomType:          ovhtypes.TfBoolType{},
			Optional:            true,
			Description:         "Include secret data (warning: if true, secret data will be saved in the terraform state)",
			MarkdownDescription: "Include secret data (warning: if true, secret data will be saved in the terraform state)",
		},
		"metadata": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"cas_required": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Computed:            true,
					Description:         "The “Cas” parameter will be required for each write request if set to true. When the “cas” (Check and set) is specified, the current version of the secret is verified before updating it.",
					MarkdownDescription: "The “Cas” parameter will be required for each write request if set to true. When the “cas” (Check and set) is specified, the current version of the secret is verified before updating it.",
				},
				"created_at": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Time of creation of the secret",
					MarkdownDescription: "Time of creation of the secret",
				},
				"current_version": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "The secret version",
					MarkdownDescription: "The secret version",
				},
				"custom_metadata": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Custom metadata",
					MarkdownDescription: "Custom metadata",
				},
				"deactivate_version_after": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Time duration before a version is deactivated",
					MarkdownDescription: "Time duration before a version is deactivated",
				},
				"max_versions": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "The number of versions to keep (10 default)",
					MarkdownDescription: "The number of versions to keep (10 default)",
				},
				"oldest_version": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "The secret oldest version",
					MarkdownDescription: "The secret oldest version",
				},
				"updated_at": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Time of the last update of the secret",
					MarkdownDescription: "Time of the last update of the secret",
				},
			},
			CustomType: MetadataType{
				ObjectType: types.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Secret metadata",
			MarkdownDescription: "Secret metadata",
		},
		"okms_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Okms ID",
			MarkdownDescription: "Okms ID",
		},
		"path": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Path",
			MarkdownDescription: "Path",
		},
		"version": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Computed:            true,
			Description:         "Secret version. If not set, the latest version will be returned",
			MarkdownDescription: "Secret version. If not set, the latest version will be returned",
		},
	}

	return schema.Schema{
		Description: "Retrieve a secret",
		Attributes:  attrs,
	}
}

type OkmsSecretModel struct {
	Cas         ovhtypes.TfInt64Value  `tfsdk:"cas" json:"cas"`
	Iam         IamValue               `tfsdk:"iam" json:"iam"`
	IncludeData ovhtypes.TfBoolValue   `tfsdk:"include_data" json:"includeData"`
	Metadata    MetadataValue          `tfsdk:"metadata" json:"metadata"`
	OkmsId      ovhtypes.TfStringValue `tfsdk:"okms_id" json:"okmsId"`
	Path        ovhtypes.TfStringValue `tfsdk:"path" json:"path"`
	Version     SecretVersionValue     `tfsdk:"version" json:"version"`
}

// OkmsSecretDataSourceModel intentionally differs from OkmsSecretModel (resource) by:
//   - not including the CAS field (not exposed in data source schema)
//   - exposing version as an int64 (selected or current version id) rather than nested object
//   - include_data flag to request secret payload
type OkmsSecretDataSourceModel struct {
	Iam         IamValue               `tfsdk:"iam" json:"iam"`
	IncludeData ovhtypes.TfBoolValue   `tfsdk:"include_data" json:"includeData"`
	Metadata    MetadataValue          `tfsdk:"metadata" json:"metadata"`
	OkmsId      ovhtypes.TfStringValue `tfsdk:"okms_id" json:"okmsId"`
	Path        ovhtypes.TfStringValue `tfsdk:"path" json:"path"`
	Data        ovhtypes.TfStringValue `tfsdk:"data" json:"data"`
	Version     ovhtypes.TfInt64Value  `tfsdk:"version" json:"version"`
}

type MetadataValue struct {
	CasRequired            ovhtypes.TfBoolValue                              `tfsdk:"cas_required" json:"casRequired"`
	CreatedAt              ovhtypes.TfStringValue                            `tfsdk:"created_at" json:"createdAt"`
	CurrentVersion         ovhtypes.TfInt64Value                             `tfsdk:"current_version" json:"currentVersion"`
	CustomMetadata         ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue] `tfsdk:"custom_metadata" json:"customMetadata"`
	DeactivateVersionAfter ovhtypes.TfStringValue                            `tfsdk:"deactivate_version_after" json:"deactivateVersionAfter"`
	MaxVersions            ovhtypes.TfInt64Value                             `tfsdk:"max_versions" json:"maxVersions"`
	OldestVersion          ovhtypes.TfInt64Value                             `tfsdk:"oldest_version" json:"oldestVersion"`
	UpdatedAt              ovhtypes.TfStringValue                            `tfsdk:"updated_at" json:"updatedAt"`
	state                  attr.ValueState
}

func (v *OkmsSecretModel) MergeWith(other *OkmsSecretModel) {

	if (v.Cas.IsUnknown() || v.Cas.IsNull()) && !other.Cas.IsUnknown() {
		v.Cas = other.Cas
	}

	if (v.Iam.IsUnknown() || v.Iam.IsNull()) && !other.Iam.IsUnknown() {
		v.Iam = other.Iam
	}

	if (v.IncludeData.IsUnknown() || v.IncludeData.IsNull()) && !other.IncludeData.IsUnknown() {
		v.IncludeData = other.IncludeData
	}

	if (v.Metadata.IsUnknown() || v.Metadata.IsNull()) && !other.Metadata.IsUnknown() {
		v.Metadata = other.Metadata
	}

	if (v.OkmsId.IsUnknown() || v.OkmsId.IsNull()) && !other.OkmsId.IsUnknown() {
		v.OkmsId = other.OkmsId
	}

	if (v.Path.IsUnknown() || v.Path.IsNull()) && !other.Path.IsUnknown() {
		v.Path = other.Path
	}

	// The create/read OKMS API does not echo back the version payload (especially the data),
	// so ensure we preserve an existing Version value from the state/plan when the response omits it.
	if (v.Version.Data.IsUnknown() || v.Version.Data.IsNull()) && !other.Version.Data.IsUnknown() && !other.Version.Data.IsNull() {
		v.Version = other.Version
	}

}

func (v *OkmsSecretModel) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		toMarshal["metadata"] = v.Metadata
	}
	if !v.Path.IsNull() && !v.Path.IsUnknown() {
		toMarshal["path"] = v.Path
	}

	toMarshal["version"] = v.Version

	return json.Marshal(toMarshal)
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	casRequiredAttribute, ok := attributes["cas_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cas_required is missing from object`)

		return nil, diags
	}

	casRequiredVal, ok := casRequiredAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cas_required expected to be ovhtypes.TfBoolValue, was: %T`, casRequiredAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	currentVersionAttribute, ok := attributes["current_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_version is missing from object`)

		return nil, diags
	}

	currentVersionVal, ok := currentVersionAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_version expected to be ovhtypes.TfInt64Value, was: %T`, currentVersionAttribute))
	}

	customMetadataAttribute, ok := attributes["custom_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_metadata is missing from object`)

		return nil, diags
	}

	customMetadataVal, ok := customMetadataAttribute.(ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_metadata expected to be ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue], was: %T`, customMetadataAttribute))
	}

	deactivateVersionAfterAttribute, ok := attributes["deactivate_version_after"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deactivate_version_after is missing from object`)

		return nil, diags
	}

	deactivateVersionAfterVal, ok := deactivateVersionAfterAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deactivate_version_after expected to be ovhtypes.TfStringValue, was: %T`, deactivateVersionAfterAttribute))
	}

	maxVersionsAttribute, ok := attributes["max_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_versions is missing from object`)

		return nil, diags
	}

	maxVersionsVal, ok := maxVersionsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_versions expected to be ovhtypes.TfInt64Value, was: %T`, maxVersionsAttribute))
	}

	oldestVersionAttribute, ok := attributes["oldest_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oldest_version is missing from object`)

		return nil, diags
	}

	oldestVersionVal, ok := oldestVersionAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oldest_version expected to be ovhtypes.TfInt64Value, was: %T`, oldestVersionAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		CasRequired:            casRequiredVal,
		CreatedAt:              createdAtVal,
		CurrentVersion:         currentVersionVal,
		CustomMetadata:         customMetadataVal,
		DeactivateVersionAfter: deactivateVersionAfterVal,
		MaxVersions:            maxVersionsVal,
		OldestVersion:          oldestVersionVal,
		UpdatedAt:              updatedAtVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	casRequiredAttribute, ok := attributes["cas_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cas_required is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	casRequiredVal, ok := casRequiredAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cas_required expected to be ovhtypes.TfBoolValue, was: %T`, casRequiredAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	currentVersionAttribute, ok := attributes["current_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_version is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	currentVersionVal, ok := currentVersionAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_version expected to be ovhtypes.TfInt64Value, was: %T`, currentVersionAttribute))
	}

	customMetadataAttribute, ok := attributes["custom_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_metadata is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	customMetadataVal, ok := customMetadataAttribute.(ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_metadata expected to be ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue], was: %T`, customMetadataAttribute))
	}

	deactivateVersionAfterAttribute, ok := attributes["deactivate_version_after"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deactivate_version_after is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	deactivateVersionAfterVal, ok := deactivateVersionAfterAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deactivate_version_after expected to be ovhtypes.TfStringValue, was: %T`, deactivateVersionAfterAttribute))
	}

	maxVersionsAttribute, ok := attributes["max_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_versions is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	maxVersionsVal, ok := maxVersionsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_versions expected to be ovhtypes.TfInt64Value, was: %T`, maxVersionsAttribute))
	}

	oldestVersionAttribute, ok := attributes["oldest_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oldest_version is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	oldestVersionVal, ok := oldestVersionAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oldest_version expected to be ovhtypes.TfInt64Value, was: %T`, oldestVersionAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		CasRequired:            casRequiredVal,
		CreatedAt:              createdAtVal,
		CurrentVersion:         currentVersionVal,
		CustomMetadata:         customMetadataVal,
		DeactivateVersionAfter: deactivateVersionAfterVal,
		MaxVersions:            maxVersionsVal,
		OldestVersion:          oldestVersionVal,
		UpdatedAt:              updatedAtVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

func (v *MetadataValue) UnmarshalJSON(data []byte) error {
	type JsonMetadataValue MetadataValue

	var tmp JsonMetadataValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CasRequired = tmp.CasRequired
	v.CreatedAt = tmp.CreatedAt
	v.CurrentVersion = tmp.CurrentVersion
	v.CustomMetadata = tmp.CustomMetadata
	v.DeactivateVersionAfter = tmp.DeactivateVersionAfter
	v.MaxVersions = tmp.MaxVersions
	v.OldestVersion = tmp.OldestVersion
	v.UpdatedAt = tmp.UpdatedAt

	v.state = attr.ValueStateKnown

	return nil
}

func (v *MetadataValue) MergeWith(other *MetadataValue) {

	if (v.CasRequired.IsUnknown() || v.CasRequired.IsNull()) && !other.CasRequired.IsUnknown() {
		v.CasRequired = other.CasRequired
	}

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if (v.CurrentVersion.IsUnknown() || v.CurrentVersion.IsNull()) && !other.CurrentVersion.IsUnknown() {
		v.CurrentVersion = other.CurrentVersion
	}

	if (v.CustomMetadata.IsUnknown() || v.CustomMetadata.IsNull()) && !other.CustomMetadata.IsUnknown() {
		v.CustomMetadata = other.CustomMetadata
	}

	if (v.DeactivateVersionAfter.IsUnknown() || v.DeactivateVersionAfter.IsNull()) && !other.DeactivateVersionAfter.IsUnknown() {
		v.DeactivateVersionAfter = other.DeactivateVersionAfter
	}

	if (v.MaxVersions.IsUnknown() || v.MaxVersions.IsNull()) && !other.MaxVersions.IsUnknown() {
		v.MaxVersions = other.MaxVersions
	}

	if (v.OldestVersion.IsUnknown() || v.OldestVersion.IsNull()) && !other.OldestVersion.IsUnknown() {
		v.OldestVersion = other.OldestVersion
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v MetadataValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"casRequired":            v.CasRequired,
		"createdAt":              v.CreatedAt,
		"currentVersion":         v.CurrentVersion,
		"customMetadata":         v.CustomMetadata,
		"deactivateVersionAfter": v.DeactivateVersionAfter,
		"maxVersions":            v.MaxVersions,
		"oldestVersion":          v.OldestVersion,
		"updatedAt":              v.UpdatedAt,
	}
}
func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cas_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["current_version"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["custom_metadata"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["deactivate_version_after"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_versions"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["oldest_version"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.CasRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cas_required"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CurrentVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_version"] = val

		val, err = v.CustomMetadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_metadata"] = val

		val, err = v.DeactivateVersionAfter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deactivate_version_after"] = val

		val, err = v.MaxVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_versions"] = val

		val, err = v.OldestVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oldest_version"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cas_required":             ovhtypes.TfBoolType{},
			"created_at":               ovhtypes.TfStringType{},
			"current_version":          ovhtypes.TfInt64Type{},
			"custom_metadata":          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
			"deactivate_version_after": ovhtypes.TfStringType{},
			"max_versions":             ovhtypes.TfInt64Type{},
			"oldest_version":           ovhtypes.TfInt64Type{},
			"updated_at":               ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cas_required":             v.CasRequired,
			"created_at":               v.CreatedAt,
			"current_version":          v.CurrentVersion,
			"custom_metadata":          v.CustomMetadata,
			"deactivate_version_after": v.DeactivateVersionAfter,
			"max_versions":             v.MaxVersions,
			"oldest_version":           v.OldestVersion,
			"updated_at":               v.UpdatedAt,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CasRequired.Equal(other.CasRequired) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CurrentVersion.Equal(other.CurrentVersion) {
		return false
	}

	if !v.CustomMetadata.Equal(other.CustomMetadata) {
		return false
	}

	if !v.DeactivateVersionAfter.Equal(other.DeactivateVersionAfter) {
		return false
	}

	if !v.MaxVersions.Equal(other.MaxVersions) {
		return false
	}

	if !v.OldestVersion.Equal(other.OldestVersion) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cas_required":             ovhtypes.TfBoolType{},
		"created_at":               ovhtypes.TfStringType{},
		"current_version":          ovhtypes.TfInt64Type{},
		"custom_metadata":          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
		"deactivate_version_after": ovhtypes.TfStringType{},
		"max_versions":             ovhtypes.TfInt64Type{},
		"oldest_version":           ovhtypes.TfInt64Type{},
		"updated_at":               ovhtypes.TfStringType{},
	}
}
